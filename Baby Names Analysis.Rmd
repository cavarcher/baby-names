---
title: "Baby Names Analysis"
author: "Connor Lennard"
date: "2023-02-02"
output: html_document
params: 
  url: "https://www.ssa.gov/oact/babynames/names.zip"
  target_name: "Name"
  target_sex: 
    input: radioButtons
    label: "Sex"
    choices: c("Male", "Female")
  begin_year: 
    label: "Begin Year"
    value: 1950
    input: slider
    min: 1880
    max: 2021
    step: 1
    sep: ""
  end_year:
    label: "Begin Year"
    value: 2021
    input: slider
    min: 1880
    max: 2021
    step: 1
    sep: ""
  num_names: 
    label: "Number of Names to Compare"
    value: 100
    input: text
  comparison_sex: radioButtons(label = "Sex", choices = c("Male", "Female"), selected = "Male")
  num_displayed:  
    label: "Number of Names to Display"
    value: 10
    input: text
  display_progress:
    label: "Display Console"
    input: checkbox
    value: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(repos = c(CRAN="https://cran.r-project.org/"))
```

## Baby Names Analysis

This project is for me to analyze baby name trends in the US. The data comes from <https://www.ssa.gov/oact/babynames/names.zip> and is loaded into a data frame. The goal is to find the names that are most similar to a target name in rank over the years. This is a way for my wife and I to find names we like for our second child given the older sibling's name.

# Load Required Libraries

```{r}
install.packages("dplyr")
library(dplyr)
install.packages("tidyverse")
library(tidyverse)
install.packages("ggplot2")
library(ggplot2)
install.packages("data.table")
library(data.table)
install.packages("shiny")
library(shiny)
```

# Required Variables

This is where you can change the source URL if necessary, as well as the years to look at for analysis and the target name for comparison

```{r}
#url <- "https://www.ssa.gov/oact/babynames/names.zip"
#target_name <- "Rose"
#target_sex <- "F"
#begin_year <- 1880
#end_year <- 2021
#num_names <- 1000
#comparison_sex <- "M"
#num_displayed <- 10
#display_progress <- TRUE
```

# Functions

These functions are called by the later code.

## Delta_From_Median_Vector

The real workhorse for the project. This function will take a given name, find the overall median of the rank and then calculate the difference by standard deviation in each year. This allows names with dissimilar counts to be compared numerically as to the general shape of the graph. If the name does not appear in the data for a specified year, the rank will be set to the max rank in that year plus one and then the difference from the median will be calculated.

The function should return a data frame with a row for every year that has the target name's deviation from the median as a ratio of the standard deviation

```{r}
# Return a vector of each year's deviation from the total median
delta_from_median_vector <- function(names, v_name, v_sex){
  # Filter the data so it's only for the name and sex specified
  filtered_list <- names %>%
    filter(name==v_name & sex==v_sex)
  
  #Find the median count
  med <- summarize(filtered_list, m = median(rank)) %>% 
        pull(m)
  #print(summarize(filtered_list, m = median(rank)))
  std <- summarize(filtered_list, s = sd(rank)) %>% 
    pull(s)
  #print(summarize(filtered_list, s = sd(rank)))
  
  med_deltas <- data.frame()
  for (i in params$begin_year:params$end_year){
    #filter for only the current year's row
    #should return either one or zero rows
    year_list <- filtered_list[filtered_list$year==i,]
    #If the list has more then 0 rows, we have a rank for that year and can
    #evaluate the difference from median
    if(nrow(year_list)>0){
      med_deltas <- rbind(med_deltas, (year_list[1,5]-med)/std)
      #print(paste(v_name,"delta is",(year_list[1,5]-med)/std,"in",i))
      #print(year_list)
    }
    
    #If it has zero rows, that name did not appear on the SSA's data for that
    #that year. Set the rank to the max rank that year+1 and evaluate
    else{
      max_rank <- nrow(filter(names, year==i))
      #print(paste("Max Rank:",max_rank))
      #print(paste("Median:",med))
      #print(paste("SD:",std))
      med_deltas <- rbind(med_deltas, (max_rank+1-med)/std)
      #print(paste(v_name,"not found in",i,"delta set to",(max_rank+1-med)/std))
    }
  }
  
  return (med_deltas)
}
```

# Code Execution

## SSA_Data

This code will load the specified url and build a data frame with the specified years. If you want to change the year range, change the variables.

```{r}
#download data from the SSA website
download.file(params$url, "babynames.zip")
unzip("babynames.zip")
#build the data frame with all names between the two years
#columns will be name, sex, count, year and rank
ssa_data <- data.frame()
  
#Read each file from the range of years
for (x in params$begin_year:params$end_year){
    
  # reads the initial table in from the .txt
  # 3 columns: name, sex and count. 
  # need to add year and then add onto total data frame
  # source files are ordered by sex (F then M) and then by count desc
  year_names <- read.table(paste("yob",x,".txt",sep=""), 
                             header=FALSE, 
                             sep=",")
    
  #create a vector that is the same length as the data frame with the year in each row
  year_vector <-rep(c(x),each=nrow(year_names))
    
  #add the year as the fourth column
  year_names <- cbind(year_names, year_vector)
    
  #name the columns
  names(year_names) <- c("name", "sex", "count", "year")
    
  #order the names by popularity
  year_names <- year_names[ order(-year_names$count),]
    
  #add rank as the fifth column
  year_names <- year_names %>%
    mutate(rank = row_number())
    
  #Add the final data frame for the year onto ssa_data
  ssa_data <- rbind(ssa_data,year_names)
  }
  
#name the columns in ssa_data
#I did this here to avoid using an attribute[5] with a vector[0]
colnames(ssa_data) <- c("name","sex","count","year", "rank")

rownames(ssa_data) <- NULL
```

## Unique_Names

Make a list of unique names from the data and find the total count over all years. You should only need to run this once.

```{r}
#Create a new data table (uses keys)
unique_names <- data.table(ssa_data)
#Set the key to the union of name a sex
setkey(unique_names, name, sex)
#Make dt a data table with unique rows for name and sex. Include a 3rd column that totals all counts of the name and sex across all years
unique_names <- unique_names[, sum(count), by=list(name,sex)]
#Name the columns
names(unique_names) <- c("name", "sex", "total")
#Order based on total in decreasing order
unique_names <- as.data.frame(unique_names[order(unique_names$total, decreasing=TRUE),])
#Reset the row names
rownames(unique_names) <- NULL
```

## Optional File Write

```{r}
#Use this line to write a .csv with the full name data if desired

write.csv(ssa_data, "Social_Security_Names_by_Year.csv", row.names=TRUE)

write.csv(unique_names, "Unique_Names_By_Total_Count.csv", row.names=TRUE)
```

## Find the Closest Names

Go through the list of name, given a target name, get a vector of all unique names ordered by sameness to the target name

```{r}
#Find the list of the target name's deviation from the median
target_name_delta <- delta_from_median_vector(ssa_data, params$target_name, params$target_sex)

#new data frame for the result after the for loop
result_list <- data.frame()
#iterate through each name and find the delta number.
#add to a data frame with name, sex and delta number
last_percent <- -1
for(i in 1:min(nrow(unique_names),params$num_names)){
  #percent complete print out
  if(params$display_progress){
    percent <- round(i/min(nrow(unique_names),params$num_names)*100)
    if(percent>last_percent){
      print(paste(percent,"% completed"))
      last_percent <- percent
    }

  }
  
  #error handling for names that do not have a rank every year.
  tryCatch(
    {
      name_i <- unique_names[i,1]
      sex_i <- unique_names[i,2]
      delta_i <- delta_from_median_vector(ssa_data, name_i, sex_i)
      diff_i <- sum(abs(target_name_delta - delta_i))
      result_list <- rbind(result_list, c(name_i, sex_i, as.double(diff_i)))
    },
    error=function(cond){
      #Should not happen with corrected delta_from_median_vector function
      print(paste("Dropping ",name_i,sep=""))
    }
  )
}
colnames(result_list) <- c("name", "sex", "difference")
result_list <- result_list[order(as.double(result_list$difference)),]
```

## Visualize

Visualize top names as specified in the variables. Displayed as a line graph of rank

```{r}
filtered_list <- filter(result_list, sex==params$comparison_sex)
for (i in 1:min(params$num_displayed,nrow(result_list))){
  name_i <- filtered_list[i,1]
  sex_i <- filtered_list[i,2]
  print(paste("Comparing",params$target_name,"and",name_i))
  print(
    ggplot(filter(ssa_data,(name==params$target_name & sex==params$target_sex) | (name==name_i & sex==sex_i)))+
    geom_point(mapping=aes(x=year, y=rank, color=name))+
    geom_line(mapping=aes(x=year, y=rank, color=name))+
    labs(title=paste("Rank of",params$target_name,"and",name_i))+
    scale_color_manual(values = c("blue","red"))+
    scale_y_reverse()+
    facet_wrap(~name, scales ="free")
    )
}
```
